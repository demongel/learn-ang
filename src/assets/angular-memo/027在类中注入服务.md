
1. 当完成了Angular依赖注入的配置后，注入器通过提供商创建依赖，创建依赖的过程可以这么理解：注入器将查找具体token值对应的提供商，然后使用该提供商创建对象实例，作为依赖项存储在注入器中。当完成了依赖的创建后，我们就可以通过依赖注入的方式，在Angular中使用该依赖的服务实例的方法和属性了。 

2. 选择不同的注入器，或在不同的位置配置提供商，服务在Web应用程序中的可见性是不同的。如providedIn属性配置为root时，服务是单例的；也就是说，在指定的注入器中最多只有某个服务的一个实例。

3. Angular的依赖注入具有分层注入体系，Web应用程序有且只有一个根注入器。这意味着下级注入器也可以创建它们自己的服务实例。Angular会有规律地创建下级注入器。每当Angular创建一个在@Component()装饰器中指定了providers属性的组件实例时，它也会为该组件实例创建一个新的子注入器。同样，当在运行期间加载一个新的NgModule类时，Angular也可以为它创建一个拥有自己的提供商的注入器。

4. 子模块和组件注入器彼此独立，并且会为所提供的服务分别创建自己的服务实例。当Angular销毁NgModule类或组件实例时，也会销毁这些注入器和注入器中的那些服务实例。

5. 子组件注入器是其父组件注入器的子节点，它会继承所有的祖先注入器，其终点则是Web应用程序的根注入器


##### 几种不同的注入方式

1. 注入依赖类实例
- 我们可以通过类的构造函数注入依赖类，即在构造函数中指定参数的类型为注入的依赖类。下面的代码是某个组件类的构造函数，它要求注入LogService类。

```ts
constructor(private logService: LogService)
```
- 注入器将会查找token值为LogService类的提供商，然后将该提供商创建的对象实例作为依赖项，赋值给logService变量。

2. 注入可选的依赖类实例
- 在实际应用中，有时候某些依赖服务是可有可无的，换句话说，可能存在需要的依赖服务找不到的情况。这时，我们可以通过@Optional()装饰器来显式地声明依赖服务，告知Angular这是一个可选的依赖服务。同时，我们需要通过代码中的条件来判断依赖服务是否存在，代码如下。
```ts
constructor(@Optional() private logService: LogService) {
  if (this.logService) { // 判断是否存在
     // 具体业务逻辑
  }
}
```

3.  使用@Inject()装饰器指定注入实例
- 当我们遇到注入的依赖类是一个值对象、数组或者接口的情况时，需要使用@Inject()装饰器来显式地指明依赖类的token值。如之前我们使用InjectionToken类封装了一个接口类型的依赖，然后期望在组件或者服务类中注入该接口类型的依赖时，需要使用@Inject()装饰器来显式地指明依赖的token值，代码如下

```ts
// 注意这里需要使用@Inject()装饰器，conﬁgToken是该接口依赖的token值
constructor(@Inject(conﬁgToken) private conﬁg: Conﬁg) { // Conﬁg是注入依赖的类型
  console.log('new instance is created');
}
```

- 又如，我们在服务中配置一个值提供商，然后在类中注入该值提供商创建的值。
```ts
providers: [{
  provide: 'name',
  useValue: '变量name的值'
}]
constructor(@Inject('name') private conﬁg: String) { // String是注入依赖的类型
  this.title = '值Provide: ' + conﬁg;
}
```

4. 注入Injector类对象实例
- Injector类是Angular的注入器对应的Class类。既然注入器创建和维护着依赖，那么我们可以直接注入Injector类对象实例，然后通过它的方法获取依赖。上面介绍的注入值类型，可以用下面的方式实现。

```ts
providers: [{
 provide: 'name',
 useValue: '变量name的值'
}]
constructor(private injector: Injector) { // 注入Injector类对象实例
  this.title = '值Provide: ' + injector.get('name');
}
```





